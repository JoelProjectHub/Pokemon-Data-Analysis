# -*- coding: utf-8 -*-
"""PokeEDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11z03oIV78K51Kr8fcIkoo8qNwvYQAr0i

# Exploratory Data Analysis on Pokémon Dataset
## Introduction
The Pokémon dataset contains detailed information about various Pokémon species, including their base stats, types, legendary status, and generation. Each Pokémon has attributes such as HP, Attack, Defense, Speed, and whether it possesses one or two elemental types. The dataset also includes indicators for legendary Pokémon, which are typically rarer and more powerful.

Our task is to explore the dataset to uncover patterns in Pokémon characteristics, compare single vs. dual types, and analyze how stats and type distributions vary across generations and legendary status.

**Business Questions**
* Which types are the most common among Pokémon?
* How do Single Type and Dual Type Pokémon compare in distribution?
* Which Pokémon types have the highest average base stats?
* Are Legendary Pokémon significantly stronger than non-Legendaries?
* How are stats distributed across different generations?
* Which stat (Attack, Defense, Speed, etc.) has the highest variance among Pokémon?
* Is there a relationship between having two types and overall stat totals?
---
## Preparing the Environment
We will import the required libraries:
* Pandas - Data manipulation
* Matplotlib and Seaborn - Data visualization
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

from scipy.stats import ttest_ind
from scipy.stats import linregress

df = pd.read_csv('pokemon.csv')

"""## Data Exploration

Lets have a look at the general data using the df.head() funciuon.
"""

pd.set_option('display.max_columns', None)
df.head()

"""From first glance at the data, we can note:
* Basic identifiers: such as Pokédex number, generation, and whether the Pokémon is legendary.
* Typing information: primary and secondary types (type1 and type2).
* Battle statistics: including HP, Attack, Defense, Special Attack, Special Defense, and Speed.
* Type effectiveness: *against_* columns show multipliers for how effective other types are against the Pokémon (e.g., against_fire = 2.0 means it takes double damage from fire).
* Abilities: stored as lists of possible abilities for each Pokémon.

We'll check to make sure the types are as expected.
"""

# Shape of data
df.shape

df.info()

# Check for duplicate entries
duplicates = df[df.duplicated()]
if duplicates.shape[0] == 0:
  print("No duplicates")
else:
  print("Duplicates found!")
  print(duplicates)

"""There are 801 rows and 41 columns. Data types are consistent o what we expect. There are no duplicates in the data.

## Descriptive Statistics

We will then delve in descriptive statistical analysis. We will use df.describe() to measure species stats.
"""

df.describe()

"""We're able to note various trends:

**Missing Data**
* *height_m* and *weight_m* have fewer counts (781 vs 801) meaning 20 pokemon have missing height/weight values.
* *percentage_male* has only 703 entries.

**Stats: *Attack / Sp. Attack / Defense / Sp. Defense / Speed***
* While stats tend to have a mean of ~70 and a standard deviation of ~30, there are still extreme outliers going over 200.

**Type Effectiveness: *against_***
* Most values cluster around 1, suggesting even distrubtion of effectivness.

**Physical Attributes**
* There is a large standard deviation of 100kg and 1 meter suggesting a wide variety of shapes and sizes.

**Legendary**
* Only 8.7% of species are considered legendary

# Exploratory Data Analysis

## 1. Which types are most common?
"""

fig, axs = plt.subplots(1, 2, figsize=(20, 6))

rainbow = sns.color_palette("hsv", len(df['type1']))

type1_counts = df['type1'].value_counts()
sns.barplot(x=type1_counts.index, y=type1_counts.values, ax=axs[0], color='royalblue')
axs[0].set_xticklabels(axs[0].get_xticklabels())
axs[0].set_title("Primary Pokemon Types")
axs[0].set_ylabel("Counts")

type2_counts = df['type2'].value_counts()
sns.barplot(x=type2_counts.index, y=type2_counts.values, ax = axs[1], color='seagreen')
axs[1].set_xticklabels(axs[1].get_xticklabels(), rotation=45)
axs[1].set_title("Secondary Pokemon Types")
axs[1].set_ylabel("Counts")

plt.tight_layout()
plt.show()

"""We can clearly see that the primary types have a consistent downward trend with water being the dominant type. Secondary, is less consistent with flying being the clear lead having twice the count as its runner up. I think it's interesting how fire is fifth most common as primary. Being one of the games base types, I would expect it higher.

## 2. What types have the best/worst stats?
"""

BOLD = '\033[1m'
END = '\033[0m'

stats_col = ['hp', 'attack', 'defense', 'sp_attack', 'sp_defense', 'speed']

type1_stats = pd.DataFrame(df.groupby(['type1'])[stats_col].mean())
type2_stats = pd.DataFrame(df.groupby(['type2'])[stats_col].mean())

# Create dictionaries
strongest_type1 = {}
weakest_type1 = {}
strongest_type2 = {}
weakest_type2 = {}

for stat in stats_col:
    # Capitalize for dictionary keys
    key = stat.replace('_', ' ').title().replace(' ', '_')

    # Top 5 for Type1
    top5 = list(type1_stats.sort_values(by=stat, ascending=False).index[0:5])
    strongest_type1[key] = top5

    # Bottom 5 for Type1
    bottom5 = list(type1_stats.sort_values(by=stat, ascending=True).index[0:5])
    weakest_type1[key] = bottom5

    # Top 5 for Type2
    top5_t2 = list(type2_stats.sort_values(by=stat, ascending=False).index[0:5])
    strongest_type2[key] = top5_t2

    # Bottom 5 for Type2
    bottom5_t2 = list(type2_stats.sort_values(by=stat, ascending=True).index[0:5])
    weakest_type2[key] = bottom5_t2

print(BOLD + "Strongest Type1:" + END, strongest_type1, "\n")
print(BOLD + "Weakest Type1:" + END, weakest_type1, "\n")
print(BOLD + "Strongest Type2:" + END, strongest_type2, "\n")
print(BOLD + "Weakest Type2:" + END, weakest_type2, "\n")

# Convert to DataFrames
strongest_df = pd.DataFrame(strongest_type1)
weakest_df = pd.DataFrame(weakest_type1)

# Count frequency of types
def count_types(data_dict):
    counts = {}
    for stat, types in data_dict.items():
        for t in types:
            counts[t] = counts.get(t, 0) + 1
    return counts

strongest_counts = count_types(strongest_type1)
weakest_counts = count_types(weakest_type1)

# Combine into one DataFrame for heatmap
all_types = set(df['type1'])
heatmap_df = pd.DataFrame(index=list(all_types), columns=['STRONG', 'WEAK']).fillna(0)

for t, c in strongest_counts.items():
    heatmap_df.loc[t, 'STRONG'] = c
for t, c in weakest_counts.items():
    heatmap_df.loc[t, 'WEAK'] = c

heatmap_df = heatmap_df.astype(float)
for t in all_types:
  if t not in heatmap_df.index:
    heatmap_df.loc[t] = [0, 0]
heatmap_df = heatmap_df.sort_values(by=['STRONG', 'WEAK'], ascending=[False, True])

# Plot heatmap
plt.figure(figsize=(30, 5))
sns.heatmap(heatmap_df, annot=True, cmap='coolwarm', cbar=True, fmt='g')
plt.title("Frequency of Pokémon Types in Strongest vs Weakest Stats (Type1)")
plt.ylabel("Type1")
plt.show()

"""The heatmap highlights the frequency of each Type 1 Pokemon appearing in the top or bottom five rankings across all base stats, making the strengths and weaknesses of each type easy to compare at a glance. The types near the top can be considered strongest on average, decreasing as you descend.

From the visualization, it's clear that Dragon and Steel types dominate the upper end of the stat spectrum, consistently appearing among the strongest categories while showing virtually no representation on the weak side. In contrast, Bug and Poison types never make it into the top five for any stat and appear frequently among the weakest, underscoring their status as some of the least powerful types overall.

Interestingly, Grass types do not appear in the top five for any stat but are flagged for weak HP values. Given that Grass is a common starter type in the games, this supports the argument that, as a whole, it may be among the least competitive species categories.

---
**Type 1 Patterns**
* Dragon is the only type to consistenly be in the top five of stats (actually top three). This would be good argument to call it the strongest type.
* Ground appears to do best in physical stats (HP, attack , defense)
* Steel dominates defense and is also high in attack and sp. defense
* Psychic is strong in sp. attack and sp. defense, but is weak in physical attack.
* Curiously the Fairy type has the strongest sp_defense and top hp but the weakest attack.
* Bug is consistently in the bottom five
* Eletric types tend to be weaker when it comes to HP, defense, and attack.
* Normal is particualrly weak in defense and sp. defense but strong in attack.

**Cross-Type Patterns**
* Dragon and Steel are universally strong as both type1 and type2.
* Bug, Normal, and Poison are consistenly the weakest of all types.
* Psychic excels in special stats but lacks physical
* Fighting is the powerhouse when it comes to attack, but severely lacks in special stats

"""

sns.set_style("darkgrid")
chosen_types = ['dragon', 'bug']

fig, axes = plt.subplots(1, len(stats_col), figsize=(22, 4))

for col, ax in zip(stats_col, axes):
  # Overall plotted as KDE
  sns.kdeplot(df[col], ax=ax, color='gray', linewidth=2, label="All Pokemon")

  # Chosen types plotted as histogram
  for t, c in zip(chosen_types, ['purple', 'green']):
    type_df = df[df['type1'] == t]
    ax.hist(type_df[col], bins=10, color=c, alpha=0.4, density=True, label=t.capitalize())

  ax.set_title(col.title())
  ax.legend()

plt.suptitle("Pokemon Stats: All vs Chosen")
plt.tight_layout()
plt.show()

"""When comparing the density curves of Dragon and Bug types against the overall Pokemon distribution, a clear contrast emerges. **Bug types** cluster heavily toward the lower end of the stat spectrum, with their density curve peaking well above the overall KDE in that region. In contrast, **Dragon types** dominate the upper end, with their curve towering over the aggregate distribution at higher stat values. This stark divergence highlights the extremes of both groups. Bug types as some of the weakest species overall, and Dragon types as some of the strongest.

## 3. How many legendary species are there? Which type has the most?
Lets figure out how common legendaries are
"""

fig, axs = plt.subplots(1, 2, figsize=(20, 6))

legendary_counts = df['is_legendary'].value_counts()
labels=legendary_counts.index.map({0: 'Non-Legendary', 1: 'Legendary'})
# plt.figure(figsize=(5,5))
axs[0].pie(
    x=legendary_counts.values,
    labels=labels,
    colors=['silver', 'gold'],
    autopct='%1.1f%%',
    startangle=50,
    explode=(0, 0.1),
    )
sns.barplot(
    x=labels,
    y=legendary_counts.values,
    hue=labels,
    ax=axs[1],
    palette=['silver', 'gold']
)
axs[1]
plt.suptitle("Legendary vs Non-Legendary Pokémon")
plt.show()

"""Only 8.7% of the species are legendary.

We can see visually see the difference between legendary and non-legendary. Pie charts are not as visually useful as bar-charts, but I still believe they are aesthetically pleasing and displaying percentages is internanlly made easier.


"""

import matplotlib.pyplot as plt
import seaborn as sns

legendary_per_type = pd.DataFrame(df.groupby('type1')['is_legendary'].apply(lambda x: x.sum()/x.count()).sort_values(ascending=False))
legendary_per_type

legendary_df = legendary_per_type.reset_index()
legendary_df.columns = ['Type', 'Legendary_Percentage']

plt.figure(figsize=(10, 6))
sns.barplot(
    x='Legendary_Percentage',
    y='Type',
    data=legendary_df,
    hue='Legendary_Percentage',
    palette='magma'
)

plt.title("Percentage of Legendary Pokémon per Type")
plt.xlabel("Legendary Percentage")
plt.ylabel("Type")

# Format x-axis as %
plt.gca().xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'{x:.0%}'))

plt.tight_layout()
plt.show()

"""We can see that the types with the hgihest rate of legendaries are flying, psychic, dragon, and steel. Everythign else is under 15%.

We can also see that there are no poison or fighting legendaries. Bug, ghost, and normal legendaries are also extremely rare being under 5%.

## 4. Are Legendaries stronger than Non-Legendaries?
"""

sns.set_style("darkgrid")

fig, axes = plt.subplots(1, len(stats_col), figsize=(22, 4))

for col, ax in zip(stats_col, axes):

  # Print out the difference
  leg_mean = df[df["is_legendary"] == 1][col].mean()
  non_leg_mean = df[df["is_legendary"] == 0][col].mean()
  print(f"{col.capitalize()} Mean Difference: ", round(leg_mean - non_leg_mean, 2))

  # Overall plotted as KDE
  for l, c in zip([1, 0], ['gold', 'silver']):

    legendary_df = df[df['is_legendary'] == l]
    name_dict = {0: "Non-Legnedary", 1: "Legendary"}
    ax.hist(legendary_df[col], bins=10, color=c, alpha=0.8, density=True, label=name_dict[l])

  ax.set_title(col.title())
  ax.legend()

plt.suptitle("Pokemon Stats: Legendary vs Non-Legendary")
plt.tight_layout()
plt.show()

df["Legendary"] = df["is_legendary"].map({0: False, 1: True})

for stat in stats_col:
    legendary_vals = df.loc[df["Legendary"] == True, stat]
    non_legendary_vals = df.loc[df["Legendary"] == False, stat]

    t_stat, p_value = ttest_ind(legendary_vals, non_legendary_vals, equal_var=False)
    print(f"{stat.title()}: p-value = {p_value}")

"""When comparing stats between Legendary and Non-Legendary pokemon, there is a clear and consistent performance gap across all base attributes.
* Mean difference are substantial, with Speical Attack showing the largest margin of ~46.5 and HP the smallest with ~29.
* Visually, Legendary pokemon will cluster near the end while Non-Legendary pokemon will cluster towards the lower to mid ranges.
* Visually, the overlap is minimal

Although obvious, we can perform a t-test to confirm the significance between these two groups. The p-values are extremely low, indicating extreme significance.

## Which Legendary pokemon are strongest?
Lets investigate further to see which types of all legnedary pokemon have the best stats on average.
"""

fig, axs = plt.subplots(1, len(stats_col), figsize=(20, 6))

legendary_by_type_stats = df[df['Legendary']].groupby('type1')[stats_col].mean()

for stat, ax in zip(stats_col, axs):
  legendary_by_type_stats_ordered = legendary_by_type_stats.sort_values(by=stat, ascending=False)
  sns.barplot(data=legendary_by_type_stats_ordered, x=stat, y='type1', ax=ax)
  #ax.set_xticklabels(ax.get_xticklabels(), rotation=90)
plt.tight_layout()
plt.show()

# Stats of Legendary Ghost Pokemon
df[(df['Legendary']==True)][['type1', 'name', 'classfication', 'generation'] + stats_col].sort_values('type1')

"""Here's what I note of importance:
**HP**
* Ghost and dark types have surprinsingly high HP. We saw in a previosly that there a very small proprotion of legendaries are actually ghost, so having a small sample size with outliers could greatly afffect their overall score.
  * I decided to look further and my assumptions were correct. There is only one Ghost pokemon, Giratina, and it has the highest HP of all legendaries.
* Fairy and Dragon are consistent to our previous findings
* Legendary Grass pokemon is also near the bottom. This is consistent to all Grass pokemon being known for being relatively frailer.

**Attack**
* Ground outperforms all other types. This is consistent when looking at all pokemon.
* Very surprisingly, Bug and Fairy Legendaries are both extremely high when compared to their Non-Legendary counterparts.
  * This could be purposefully done by creators to give a contrasting Legendary for a normally weak type.

## 5. How many dual type species are there? Which type has the most?
Lets find out how common dual types are.
"""

fig, axs = plt.subplots(1, 2, figsize=(20, 6))

df["is_dual"] = df["type2"].notna()

dual_counts = df['is_dual'].value_counts()
labels=dual_counts.index.map({False: 'Single Type', True: 'Dual Type'})
# plt.figure(figsize=(5,5))
axs[0].pie(
    x=dual_counts.values,
    labels=labels,
    colors=['lightcoral', 'limegreen'],
    autopct='%1.1f%%',
    startangle=50,
    explode=(0, 0.1),
    )
sns.barplot(
    x=labels,
    y=dual_counts.values,
    hue=labels,
    ax=axs[1],
    palette=['lightcoral', 'limegreen']
)
axs[1]
plt.suptitle("Dual vs Single Type")
plt.show()

"""About half, 52.1%, of species are dual type."""

dual_per_type = pd.DataFrame(df.groupby('type1')['is_dual'].apply(lambda x: x.sum()/x.count()).sort_values(ascending=False))
dual_per_type

dual_df = dual_per_type.reset_index()
dual_df.columns = ['Type', 'Dual_Percentage']

plt.figure(figsize=(10, 6))
sns.barplot(
    x='Dual_Percentage',
    y='Type',
    hue='Dual_Percentage',
    data=dual_df,
    palette='viridis'
)

plt.title("Percentage of Dual-Typed Pokémon per Type")
plt.xlabel("Dual-Type Percentage")
plt.ylabel("Type")

# Format x-axis as %
plt.gca().xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f'{x:.0%}'))

plt.tight_layout()
plt.show()

"""We can see that steel and rock are the most common types to have a secondary as well, while fairy and fighting are the least likely be have another type.

## Does weight and height affect stats?
Although there would need to be more exploration to link direct cause, we can show if there is any predictable correlation.
"""

df_scatter = df.dropna(subset=['weight_kg']).copy()
df_scatter = df.dropna(subset=['height_m']).copy()
df_scatter['log_weight'] = np.log1p(df_scatter['weight_kg'])
df_scatter['log_height'] = np.log1p(df_scatter['height_m'])


for x in ['log_weight', 'log_height']:
  fig, axs = plt.subplots(2, 3, figsize=(20, 6))
  axs = axs.flatten()
  for stat, ax in zip(stats_col, axs):
    sns.scatterplot(
        data = df_scatter,
        x = x,
        y = stat,
        hue = 'Legendary',
        palette = {False: 'silver', True: 'gold'},
        ax = ax)
    slope, intercept, r, p, stderr = linregress(df_scatter[x], df_scatter[stat])
    ax.plot(df_scatter[x], slope * df_scatter[x] + intercept, color='red', linewidth=2, alpha=0.5)
    ax.set_title(f"{x[4:].capitalize()} vs {stat.title()}")
    ax.set_xlabel(x)
    ax.set_ylabel(stat.title())

  plt.suptitle(f"{x} vs Stats")
  plt.tight_layout()
  plt.show()

"""When we compare the stats by the log of weight and height, we can see there is clear positive trend for all stats. Although the steps are incremental, it is obvious. This means that weight and height can indicate stats, but is not the determining factor.

I also seperated the scatter by Legendary. We can see that legendaries do tend to cluster towards the heavier/taller range. This would affect the correlation we see.
"""

